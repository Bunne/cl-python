\documentclass{article}
\topmargin -1.5cm
\oddsidemargin -0.04cm
\evensidemargin -0.04cm
\textwidth 16.59cm
\textheight 21.94cm 
\begin{document}
\title{CLPython Overview}
\author{Willem Broekema}
\date{March 2006}
\maketitle

\tableofcontents{}

\section{CLPython Introduction}
CLPython is an implementation of a Python\footnote{The native code
compiler in the Common Lisp implementation CMUCL has been called
Python since before the language with the same name was born.}
compiler in Common Lisp. This document describes how CLPython fits in
the ``Python world'', and it outlines the implementation of CLPython
-- in particular the translation of Python concepts into Common Lisp
concepts.

\subsection{Python-the-Language}
Python is a high-level programming language sharing many similarities
with Common Lisp. {\bf Multiple paradigms}: dynamically typed, first
class functions (not continuations), classes and metaclasses (less
``structured'' than Common Lisp), read-eval-print loop, garbage
collection. In Python source code, control flow is indicated by
leading whitespace.

Notable differences between Python and Comon Lisp: it is very hard to
get execution speed of Python near that of C and Lisp, because Python
behaviour is very dynamic; control flow in Common Lisp is much more
advanced; Lisp-like programming environments missing.

In the language universum, Python is a close relative of {\bf Ruby}.

\subsection{Python Compilers}
The major implementations of Python are:

\begin{enumerate}

 \item{{\bf CPython}, or just Python} -- The reference
   implementation. Python-the-language has been developed hand in hand
   with this reference implementation, and that continues to be the
   case. Started in 1991 by Guido van Rossum. Developments in the
   Python language implicitly follows from extensions of the
   functionality in CPython. Virtual machine, byte
   code. (http://www.python.org)

   Derived from CPython:
   \begin{enumerate}
    \item{{\bf Stackless}} -- With support for continuations
    \item{{\bf Starkiller}} -- ...
   \end{enumerate}

 \item{{\bf Jython}} -- Implementation in Java. Translates Python code
   into JVM code. Was the first alternative implementation. Project
   has apparently been inactive for a few years, so is behind CPython,
   but development is going on. Development started by Jim Hugunin,
   who later created IronPython. Probably used a lot for scripting
   Java applications like web servers. [Speed?]
   (http://www.jython.org)

 \item{{\bf IronPython}} -- Implementation in C\#. Runs on Microsoft .Net
   and Mono. Developed by same person who developed Jython. As fast as
   CPython. Developer hired by Microsoft to continue working on
   implementations of and support for dynamic languages on
   .Net. (http://www.ironpython.com)

   Related:
   \begin{enumerate}
    \item{{\bf Python for .Net}} -- Experiment initiated by Microsoft. Implementation
        was fairly slow. This lead to claims that .Net is inappropriate for
        very dynamic languages, but that has been refuted by IronPython. 
   \end{enumerate}

 \item{{\bf PyPy}} -- Implementation of Python in itself. Supported by
    research grants. Quite some people are involved, much
    activity. Targeting different backends, among which (eventually)
    Common Lisp. (http://codespeak.net/pypy)
  
\end{enumerate}

\section{Representation of Python Objects and Concepts}
For most of the concepts encountered in Python, corresponding Lisp
concepts were available onto which could be mapped more or less
straitforwardly.

Exceptions were {\em generators} (see \ref{sec:functions}) and the
behaviour of classes and instances (see \ref{sec:classes_instances}):
implementing these correctly, with all their hairy details, required a
non-trivial amount of work.

\subsection{Classes and Instances} \label{sec:classes_instances}
py-meta-type, py-type, py-object, py-dictless-object, py-user-type, proxy class, ...

attributes

macro def-my-method

number, lisp-val, deproxy

garbage collection

repr, str, print-object

iteration

properties

\subsection{Data structures}
\subsubsection{Numbers}
Straightforward mapping of numeric types: \\
\\
\begin{tabular}{ll}
 Python & Common Lisp \\
\hline
 int, long, bool & integer \\
 complex     & complex     \\
 float       & double-float \\
\end{tabular} \\
\\ \\
CLPython class structure for the numeric types: \\
\\ 
\begin{tabular}{ll}
\hline
py-number \\
py-complex & (py-number) \\
py-real & (py-number) \\
py-int & (py-real) \\
py-bool & (py-int) \\
py-float & (py-real) \\
\hline
\end{tabular} \\
\\
\\ In principle, (unboxed) Lisp numbers are used to represent Python
numbers. However, the user can subclass built-in types. When the user
subclasses Python class {\em int}, effectively a subclass {\em my-int}
of {\em py-int} is created. All instances of such subclasses are
really represented as CLOS instances of {\em my-int}, never
directly as Lisp numbers. \\
\\
Note:
\begin{enumerate}

 \item{} CPython does not have rationals; CLPython neither (but it would be an easy addition).

 \item{} CPython makes distinction between {\em int} and {\em long};
         the most significant difference is that the latter are
         printed with `L' suffix.  There are plans to do away with the
         difference in a future version. In CLPython, {\em int} and
         {\em long} are the same, and large numbers are not printed
         with the `L' suffix.

 \item{} CPython does not have a {\em real} class; CLPython has the
         class but does not expose it.

 \item{} CPython has class {\em bool} as subclass of {\em int}; its
         two elements are the singletons {\em True} (1) and {\em
         False} (0). {\em type(True) = type(False) = bool}. However,
         {\em True+0} and {\em True + False} are both the integer 1,
         not the boolean {\em True}; and likewise for False, so as
         soon as True or False is involved in a computation it
         ``loses'' its status of {\em bool}.

         This seems quite ugly and useless to me, therefore CLPython
         has {\tt (defconstant *the-true* 1)} and {\tt (defconstant
         *the-false* 0)}. From that, it follows that {\em type(True) =
         type(False) = int (= long)}.

 \item{} In CL complex numbers with zero imaginary part are normalized
   to a real number; in Python complex numbers can have a zero real
   part. CLPython follows CL behaviour here.

\end{enumerate}


\subsubsection{Strings, Lists and Tuples}
\begin{tabular}{lll}
 Python & Description & CLPython \\
\hline
 string & Immutable vector of (Unicode) characters & string (simple character vector) \\
 list   & Mutable vector of anything & adjustable vector \\
 tuple  & Immutable vector of anything & consed list
\end{tabular} \\
\\ \\
Note:
\begin{enumerate}

 \item{} Tuples are often used for quickly grouping say 2 to 5 values;
         lists typically contain more elements and tend to live
         longer. Also, lists are used for random access. Therefore
         lists are represented as vectors and tuples as lightweight lists.

 \item{} In Python, there is a difference between Unicode strings and
          non-unicode (byte) strings. The former are printed with a
          `u' prefix: {\em u''abc''}. In CLPyton, ``regular'' strings
          and Unicode strings are the same, and the `u' prefix is
          never printed. (There are more pure-Unicode Python
          implementations.)

 \item{} Python does not have a distinct type for arrays of bytes yet
         (but it will come). Therefore, when a Unicode string is
         encoded as bytes, the resulting byte array is again a
         (different) string.

 \item{} Tuples are immutable, in the sense that the tuple will always
          contain the same objects, but if a contained objects is
          mutable (e.g. class instance or list), those objects can be
          mutated.

 \item{} The empty Python tuple {\tt ()} is in CLPython not represented by {\em
          NIL}, as that would cause many practical problems. Instead,
          the empty tuple is a constant represented by an instance of {\em py-tuple}.
\end{enumerate}

\subsubsection{Hash tables}
Python provides hash tables under the name ``dictionaries''. The {\em
test} function is always the built-in equality test function, and the
{\em hash} function always the built-in hash functin. Nevertheless,
behaviour can be customized because each class can define equality and
hash value of its instances.


\subsubsection{Functions} \label{sec:functions}
Python functions are represented by Lisp functions. However, there are
large differences in argument handling, and it is possibile to set
attributes on user-defined functions.
\\ \\
Note:
\begin{enumerate}
 \item{} The CLPython class {\em py-function} is a subclass of {\em
     standard-generic-function}. Its instances have a dictionary, for
     storing attributes. The {\em funcallable-instance-function} is
     set to a Lisp function that handles the argument parsing and the
     subsequent function behaviour.

 \item{} Argument handling:
      Argument handling is optimized and cons-free if (1) the function
      does not define * or ** arg, (2) only positional arguments are
      supplied, and (3) number of arguments is correct. Not sure we
      can get much

 \item{} Destructuring parameters: it is possible to destructure the
      arguments to a function: {\tt def f(x, (y,z)): ...} is
      equivalent to {\tt def f(x, tmp): (x,y) = tmp;
      ...}. Destructuring form can consist of (nested) tuples only.

 \item{} Generators, yield

\end{enumerate}

\subsubsection{Files}
Python files directly represented by Lisp streams, using OSI.
\\ \\
Note:
\begin{enumerate}
 \item{} Python has no generalized {\em streams} concept.
\end{enumerate}

\subsubsection{Modules}
compare with Common Lisp packages

\subsection{Control flow}
\subsubsection{Iteration}

\subsubsection{Exceptions}
only simple handler-case

no handler-bind

translate lisp exceptions (asynch...) into Python exceptions
(KeyboardInterrupt)


\section{Compilation and Evaluation}
\subsection{REPL}
Integrate Python commands with Lisp commands
- -- ---

\subsection{Module Compilation}

\begin{enumerate}
 \item{} Lexer: Python syntax 
 \item{} Parser: with yacc into ast. Beautify trailers: x[0](). (Reverse direction: AST pretty printer)
 \item{} Compile lambda containing AST (so declarations work ok)
 \item{} Write file, dynamic variable, load hack
\end{enumerate}

\subsection{Declarations}
pydecl

\subsection{Compiler macros}
speed up iteration, printing, arithmetic?

\section{Future}
\begin{enumerate}
 \item{} Integration Lisp and Python worlds
 \item{} Advanced source code analyses tools (advanced emacs mode?)
 \item{} Optimize (numerical applications?)
 \item{} Ruby next?
\end{enumerate}

\end{document}

%%% Local Variables: 
%%% TeX-master: "/x/dev/franz/python/clpython-design.tex"
%%% End: 
