[CLPython -- Willem Broekema <willem@pastelhorn.com> -- 20040902]

Python: 
 - popular, clp, smaller learning curve
 - dirty, grows by extending syntax, hashtable-based instead of OO

Python in Lisp:
 - experiment: possible? easy? (useful?!)
 - impress Python programmers: Lisp is powerful
 - extension language for CL apps - bridge syntax difference gap


*** First a few things about Python!

Python syntax:

  - required indentation makes for clean, unambiguous code:
       if a:
         if b:
           foo()
         else:
           bar()

  - compact syntax instead of functions:
        x[i]    ~ (nth x i)        (~ meaning: approx equivalent)
        x[i:j]  ~ (subseq x i j)
        f()     ~ (f)
        f.a     ~ (slot-value f 'a)
        [a, 3]  ~ (list a 3)
        {a: 3}  ~ ((a . 3))
        x << y  ~ (ash x y)

  - syntax can be overloaded:
      `x + y'  ->  `x.__add__(y)'
       refers to a method __add__ of some (user-defined) class X

  - no declarations + overloaded syntax ->
     many decisions about the evaluation can be made only at runtime

  - need new syntax for new features:

     print x, y              ~  sys.stdout.write(x, y)

    oops, a simple way to print to a file would be handy:

     print >> file,  x, y    ~  file.write(x, y)
    
    the "print >>" syntax is considered ugly

    Common Lisp has the immense benefit of being defined only after
    must experience: FORMAT takes always a stream (designator) as
    first argument)

  - no indenting help from editor as with sexpr

  - adding something resembling Lisp macros is impossible


Python behaviour:

 - Python is dirty here and there
   good example is attribute lookup:

     to look up person.name   (the "name" attribute of object "person")

       a. if the class of "person" (say, Person), or one of Person's
          base classes (say, Animal) defines __getattribute__, 
          that will intercept all attribute lookups.
          Call:  Animal.__getattribute__(person, name)

       b. look in instance dictionary:  val = person.__dict__["name"]

            - but if it has fixed slots:
              look in person.__slots__
               and give error if "name" is not one of the fixed slots

               - unless "__dict__" is specified as one of the fixed slots:
                 in that case, don't give an error if it is not one of the
                 fixed slots, but search in the instance dictionary too

       c. look in the classes Person, Animal for an attribute called "name"

           - if it is a `descriptor', call its __get__ method
           - else, if it is a method, make it a bound method
           - else, return it unchanged

       d. if nothing found so far: look for __getattr__ method in the classes,
          and call it:  C.__getattr__(person, "name")

   and then there is _setting_ attributes...

   and comparing objects (this depends on whether the objects are of the same
     or different (sub)types, whether there are user-defined comparison
     functions (overloading '<', '<=', '!=', __cmp__)...

   and coercion attempts when operands are incompatible for some (mathematical)
   operation...


Python syntax and behaviour is irregular in many places:
   
    def foo(): return 42  # function definition: ok  
    def foo:   return 42  # error: () required

    class C: pass     # ok
    class C(): pass   # error: must be something in ()
    class C(D): pass  # ok

  ---
    012 = 10     # octal
    012. = 12.0  # decimal: ignore leading 0

  ---
    x[0,1,2] -> x.__getitem__( (0,1,2) )  tuple with 3 elements
    x[0,1]   -> x.__getitem__( (0,1)   )             2
    x[0]     -> x.__getitem__(  0      )  one param, the object itself!
                x.__getitem__( (0,)    )  instead of a tuple with one item in it

  ---
    (a,b) = [4,5] # ok: a = 4,  b = 5
    (a) = [4]     # ok: a = 4
    () = []       # error

  ---
    class MyDict(dict):
      def __getitem__(self, key):
        ..

    <instance>.__dict__ = MyDict()

       -> This dictionary assignment is allowed
          but CPython attribute lookup bypasses MyDict.__getitem__, diving
          straight into the underlying dictionary!
   

Python is a "single implementation language" in flux, giving uncertainty:

 - Can I rely on this behaviour?!

   "This function ... and the argument ... but in the future special
    meaning may be assigned to the argument, if it is of type Foo."

 - "Python" is whatever CPython does...?



*** Now, let's go to the implementation!


Python data structures compared to Lisp:

 - Python subset of CL: mapping possible everywhere:

     . objects (including exceptions): use metaclasses, inheritance, mix-ins

     . methods:
         - methods of built-in classes are (macro-generated) GFs
         - methods of user-defined classes are (for now) function objects
	    that are put in the instance's dictionary

     . numbers: straightforward

     . dictionary: hash-table with custom :hash and :test functions

     . list: consed list (maybe vector better - depends on usage (hybrid?))

     . functions: straightforward (`call rewriter' needed because of small issues
                  w.r.t. argument passing

Python control flow:

  - Python has: if x then y elif x2 then y2 else z
                while x: ..
                for x in y: ..
                try: .. except: ..
    all of which directly map to something offered by Lisp

 - in case of errors, the Lisp debugger offers much more than (standard) CPython



The work has been:

 - about one month spent on getting _insight_ in the major problems
   (how exactly classes work, boundary conditions, error situations)
   by reading documentation (python.org) and CPython source

 - getting classes/metaclasses right (took a few iterations):

     `python-object', `python-type', 
     `builtin-class', `builtin-object',
     `user-defined-object', `user-defined-class'
     `user-defined-class-w/slots', ...
     `udc-instance-w/slots', ...

 - creating Python's built-in classes, and all methods they support:
     number, list, tuple, function, module, class, method, ...

 - support defining functions, classes, methods, creating instances,
   calling functions at run-time

 - do the right thing for attribute lookups ("x.y"),
   operations ("x + y"), name lookups/scopes

 - enter grammar, make it unambiguous, make it return the right AST


State:

 - about 75 % of the CPython functionality is there

 - many things that are missing can be added within hours/days

 - biggest things missing: metaclasses, exceptions (catching the Lisp
   errors and turning them into Python exceptions)

 - no major problems expected

 - CPython has many extension libraries written in C; we can't use those


Next:

 - Make it complete

 - Compiler

 - I'll keep working on it 


Thanks!