			 YACC in Common Lisp

		 -[Thu Jul 22 15:15:54 2004 by smh]-

YACC (Yet Another Compiler Compiler) is a venerable tool from the Unix
world.  YACC is a language and compiler that builds a table-driven
parser for a LALR(1) grammar.  It was developed in the 1970's to work
with C and certain FORTRAN variants and conceptually the technology is
stable.  Although LALR(1) does not encompass the full range of
languages, most reasonable computer languages can be fit into a
LALR(1) description.

It is not the purpose of the current document to be a tutorial in
writing grammars in YACC.  That subject is covered in classic papers
and widely available manuals.  Although these resources explain YACC
use in C, the material on grammar development is independent of the
target language.  Translations of the concepts into Common Lisp should
be straightforward from the material in this document and th3e
accompanying examples.

To start learning YACC, see the original Unix paper "Yacc: Yet Another
Compiler-Compiler" by Stephen C. Johnson (available online
http://dinosaur.compilertools.net/yacc/index.html).  Similar material,
plus much more on the theory of LALR parsers, can be found in the
documentation for the Free Software Foundation Bison.  It is also
widely distributed, e.g. with Linux, and available online here:
http://www.gnu.org/software/bison/manual/

The Lisp version of YACC is straightforward.  See the accompanying
bc.cl and xml.cl examples.  A grammar is defined with the defgrammar
forms, and productions are defined with defproduction forms.  Action
code is a list of forms (i.e. a progn without the leading progn).  The
value returned by the past form in an action code is the value
returned by that code.

The implementation is in three files:

  yacc.cl	   package and class definitions
  yacc-compile.cl  grammar analysis and state-machine table computation
  yacc-runtime.cl  state machine and runtime code

The intention is that it should be possible to compute the
state-machine tables at file-compile time.  This will be implemented
in some future version, but it requires some reworking of the
metaclass initialization machinery.  When that is donw an application
could be delivered without the yacc-compile file.  But presently, all
three files are always needed.

Here follows documentation for all symbols exported from the yacc
package. (yacc:error is the same symbol as cl:error.)

defgrammar name (slot*) (superclass*) option*		[macro]

  defgrammar defines a class of grammar via expanding to a defclass
  form, appending grammar to the superclass list if it is not already
  present.  The first three subforms are otherwise as for defclass,
  and regular defclass options may appear in the options list.

  The option list may also contain these grammar-specific options:

    (:left-associative  terminal*)
    (:right-associative terminal*)
    (:non-associative   terminal*)
    (:lexemes           terminal*)

  These defines a set of terminals (either characters or tokens
  returned by the lexer) with a given precedence.  Each option may
  appear multiple times; terminals in each successive option subform
  receive successively higher precedence.  The :lexemes option is for
  terminals that don't have a specific left, right, or non-associative
  attribute.

  Initialization of the :lexer function slot of the grammar can be
  accomplished with the :lexer initarg at make-instance time of with a
  defclass :default-initarg specification, or by setf of grammar-lexer
  after the grammar is created.

  There ought to be an ensure-grammar function, but if it is necessary
  to generate grammars at execution time, study the expansion of
  defgrammar for details.

grammar-class						[class]

  This is the metaclass of all grammars.  The metaclass may be
  overridden via the :metaclass option to defgrammar which is passed
  to as the :metaclass option to defclass, but the metaclass must be
  a subclass of yacc:grammar-class.

grammar							[class]

  This is a necessary superclass for all grammars.  If not already
  present, defgrammar adds it to the superclass list of the generated
  defclass form.

defproduction (nonterm grammar) rhs &optional action-code	[macro]
	      &rest options
defproduction-1 nonterm grammar-name rhs action-fn options	[function]

  The operators define a production rule for a grammar.  nonterm is a
  nonterminal symbol, also known as the "left-hand side" (lhs) of the
  rule.  The "right-hand-side" (rhs) is a list of terminals and
  nonterminals (and action code -- see below).

  When a production is reduced, the action-code is executed.  It has
  access to the variables $1, $2, ... $n which are the values conveyed
  by each of the preceding elements in the rhs.

  Reference to the values of enclosing rules using zero or negative
  numbers, mentioned in other YACC documentation, is not supported.

  The only meaningful option is (:precedence <terminal>) which assigns
  this production the priority of the specified terminal.  Normally, a
  production is assigned the priority of the last terminal in the rhs.

  In the case of the defproduction macro, the rhs may also contain
  lists which are interpreted as action code forms to be executed when
  that portion of the rule is recognized.  (This is a convenience
  syntax that works by rewriting the production as multiple
  productions.  See the YACC manual.)

  The defproduction-1 function allows a similar syntax, except that
  the intermediate action code must be a function accepting n+1
  arguments which will be the grammar and the values of the rsh
  elements preceding it.  If there is no action code, or if it is nil,
  a production returns $1 by default, or nil if the rhs is empty.

build-grammar grammar-name &optional listingp		[macro]
build-grammar-1 grammar &optional listingp		[function]

  These operators construct the state machine description from the
  defgrammar and defproduction description, finalizing the grammar for
  parsing.  The state machine tables are stored in class-allocation
  slots of the grammar class.  Computation of the state machine
  description may be time consuming for large grammars and typically
  happens when the compiled file defining the grammar is loaded.

  It should be possible to compute the grammar description at file
  compile time, eliminating the overhead at load time.  Unfortunately,
  the macrology and metaclass machinery to do so has not been
  completed.  It may be some day.

with-terminal-codes					[macro]

tcode terminal						[local macro]

  The lexer must return two values to the state machine each time it
  is called for a new token.  These are the terminal-code which is a
  small non-negative integer, and the value if any that is carried by
  that terminal.  (These correspond to the C YACC lexer return value
  and the variable yylval.)  The value can be any lisp value, since it
  is used only by action code in rules.  But for fast execution of the
  state machine, the terminal-=code must be a nonnegative integer.

  It would be unreasonable for the lexer to be full of integer
  constants, and managing terminal codes would be tedious for the
  programmer.  Instead, YACC assigns them automatically.  The C YACC
  implements this using C #define, since yacc is a preprocessor that
  runs before the C compiler compiles the parser.  But a Lisp YACC
  program is compiled in one compilation, so the two macros above
  solve the problem.

  The body of lexer code (and any code it calls that needs to know
  terminal-codes) should be wrapped in a with-terminal-codes macro.
  That defines a lexical tcode macro which at macroexpand time will
  look up a character or symbol in the grammars set of terminals and
  return its integer code.

  The set of terminals in a grammar are the set of literal characters
  that occur in production rules plus the set if symbolic nonterminals
  declared in the defgrammar form.  Literal characters are represented
  by their character codes, and the codes for symbolic terminals are
  filled in at unused character codes.  Keeping the range of codes as
  small as possible makes grammar tables smaller.  The terminal codes
  are computed the first time a with-terminal-codes macro is
  encountered (or at build-grammar time) so the compiler must have
  processed all defproduction forms before lexer code can be compiled.

tcode-1 grammar term &optional (warnp t)	        [function]

  This is a functional version of the tcode macro.  It is available at
  compile time for use in macros.  It optionally warns if the token is
  not known in the grammar.  See the tcode-zip local macro in the
  xml.cl example, and note how to extract the grammar from the
  compile-time environment.

*yacc-trace*						[variable]

  If this runtime variable is true, the state machine will print
  parse-time debugging information to *standard-output* reporting the
  actions of the parser: the token it is examining, it's state, and
  the reduction of rules.  WHen debugging grammar problems this can be
  understood in conjunction with the state-machine listing produced
  when the second argument to build-grammar is true.

*generate-listing*					[variable]

  The default value of the listingp argument to build-grammar and
  build-grammar-1 grammar.  Initially nil.  If a listing is generated
  it is written to a file named "<grammar-name>.text".

eof							[symbol]

  This symbol is a lexical token returned to the parser by the lexer
  to indicate end of the parse token stream.  The typical idiom for
  doing so is to return (values (tcode eof) 'eof).

  It is not necessary for a grammar to recognize eof at the end of the
  parse.  The state machine does this automatically.  But it may be
  useful to have an eof in the rhs of an error recovery rule, allowing
  that rule to be reduced on eof at an ungrammatic position.  See the
  bc.cl example, and run it as

     (with-input-from-string (*standard-input* "a+") (bc))

  Without the eof in the error recovery rule, the grammar would signal
  a parse error after printing its general error message, instead of
  exiting cleanly.

error							[symbol]

  This symbol is a semantic tokens.  It appears in the right-hand
  side of a grammar rule showing places where the grammar intends to
  provide recovery from errors.  See error-resynchronized.

grammar-lexer

  An accessor on the grammar class containing the lexer function for
  the grammar.  The lexer function takes one required argument and one
  optional argument.  When the grammar requests a new token, it calls
  the lexer with one argument, the grammar itself.  When it wants some
  special action by the lexer it includes a second argument
  :report-location-p.  The lexer should return the current offset
  within the parse stream, if that mis available and makes sense,
  otherwise it may return nil.  The offset is used in error reporting.

string-grammar-mixin					[class]

  This is a convenience subclass of grammar that parses from an
  argument string.  It accepts an initarg :string and provides the
  accessors below for use by the lexer.

string-grammar-string  string-grammar-mixin		[function]
string-grammar-index   string-grammar-mixin		[function]
string-grammar-length  string-grammar-mixin		[function]

  These accessors access respectively the string being parsed by the
  grammar, the current position in the string, and the length of the
  string.  Typically these would be used by the lexer, but might also
  be used by error reporting to show the position in the input where a
  parse error occurred.

parse grammar						[function]

  This function executes the finite state machine according to the
  state transition tables contained in the grammar.  It returns only
  when the parse completes and an eof has been parsed.  During the
  parse the state machine calls out to the action code contained in
  the grammar productions as a production is reduced..

  The argument may be an instance of the grammar class, a grammar
  class, or a symbol naming a grammar class.  For the latter two, a
  fresh instance is created for the parse.

  Instances of a grammar class may be reused for efficiency.

state-machine grammar					[function]

  Called by parse.  The argument must be a grammar instance.

signal-grammar-error grammar &key :token :where :state	[function]

  This function is called by the parser state machine when it receives
  unsyntactic input and the grammar's attempt at error recovery does
  not succeed (see error-resynchronized below)..  The token is the
  illegal token, where is the location in the parse stream or nil, and
  state is the current state of the parser finite-state machine.

  It is possible that action code might want to call this for some
  situation that is not quite a parse error.  This is the definition
  of the default system method which can be overridden:

   (defmethod signal-grammar-error ((grammar grammar) &key token where state)
     (error 'grammar-parse-error
	    :grammar grammar
	    :state state
	    :token token
	    :position (or where
			  (funcall (grammar-lexer grammar) grammar
				   :report-location-p))))

grammar-parse-error					[condition class]

  This class of error is signalled when a grammar receives a token
  that violates the grammar.  It is a subclass of parse-error and has
  the following slot readers.

grammar-parse-error-grammar  error			[function]
grammar-parse-error-source   error			[function]
grammar-parse-error-state    error			[function]
grammar-parse-error-token    error			[function]
grammar-parse-error-position error			[function]

error-resynchronized grammar				[function]

  When a parse first encounters a syntax error, it searches up its
  stack of saved states for a state in which the special token `error'
  would be accepted. n If it doesn't find one, signal-grammar-error is
  called.  If it does find one, the parser continues operating in
  silent mode, trying to reduce that production by accepting tokens
  and silently discarding them until it finds something that will
  satisfy that production.  When that production is reduced, normal
  parsing continues.

  The purpose of error-resynchronized is to result normal reporting of
  syntax errors.  In some yacc implementations, silent error discard
  is automatically turned off after several tokens have been parsed
  without error, but in this implementation it is necessary to do this
  in the action code.
